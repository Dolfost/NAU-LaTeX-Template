% !TeX root = ../../../document.tex
\nocite{*}
\sffamily

\section{Тема і мета роботи}
\bigtext{Тема:} Дослідження принципів роботи алгоритмів сортування.\\
\bigtext{Мета:} Ознайомитися з різновидами алгоритмів сортування. Вивчити
алгоритм сортування вставками, методом бульбашки і їх різновиди, алгоритм
швидкого сортування та сортування злиттям. Вивчити принцип проведення
аналізу обчислювальної складності алгоритмів.

\section{Постановка задачі}
\begin{enumerate}
	\item Вивчити основні алгоритми сортування та принципи аналізу
обчислювальної складності алгоритмів.
	\item Реалізувати алгоритм відповідно до варіанту.
	\item Розрахувати обчислювальну ефективність алгоритму. Провести
порівняльний аналіз з модифікованими алгоритмами того ж принципу
сортування
\end{enumerate}
Варіант 5 (варіант \(=N\mod7\) де \(N=12\))

\section{Теоретичні відомості}
Вміст цієї секції взято з \cite{Karumanchi_2020}.
\subsection{Insertion sort}
Сортування вставками - це просте та ефективне сортування порівнянням. У цьому алгоритмі кожна ітерація видаляє елемент з вхідних даних і вставляє його в потрібну позицію в списку, що сортується. Вибір елемента, який видаляється з вхідних даних, є випадковим, і цей процес повторюється до тих пір, поки не будуть пройдені всі вхідні елементи.
\paragraph{Переваги}
\begin{itemize}
	\item Проста реалізація
	\item Ефективний на малих массивах
	\item Адаптивність: Якщо вхідний список попередньо відсортовано (навіть і не повністю), то сортування вставокою займає \(O(n + d)\), де \(d\) кількість інверсій
	\item Практично ефективніше, ніж сортування виборкою та бульбашкою, хоча всі вони
	мають складність \(O(n^2)\) у найгіршому випадку 
	\item Стабільність: Підтримує порядок вхідних даних, якщо ключі однакові
	\item Місцеве застосування: Потребує лише \(O(1)\) додаткової пам'яті
	\item В реальному часі: Сортувати масив вставками можна по мірі його отримання
\end{itemize}
\paragraph{Алгоритм}
Кожне повторення сортування вставкою видаляє елемент з вхідних даних і вставляє його на потрібну позицію у вже відсортованому списку, поки не залишиться жодного вхідного елемента. Сортування зазвичай виконується на місці. Результуючий масив після \(k\) ітерацій має властивість, за якою відсортовано перші \(k+1\) елементів.
\begin{figure}[H]
	\centering
	\includegraphics[width=.6\textwidth]{images/insertion}
	\caption{Процес сортування вставками}
	\label{fig:ins}
\end{figure}
Кожен елемент, більший за \(x\), копіюється праворуч при порівнянні з \(x\).
\subsection{Shell sort}
Сортування Шелла (також відоме як сортування за зменшенням приросту) було
винайдено Дональдом Шеллом. Цей алгоритм сортування є узагальненням сортування
вставками. Сортування вставками ефективно працює на вхідних даних, які вже
майже відсортовано. Сортування Шелла також відоме як сортування вставками з
\(n\) проміжками. Замість того, щоб порівнювати лише сусідні пари, сортування
оболонкою робить кілька проходів і використовує різні проміжки між сусідніми
елементами (закінчуючи проміжком в \(1\) або класичним сортуванням вставками).

Наприклад, якщо найменший елемент знаходиться в кінці масиву, то
при сортуванні вставками знадобиться виконати повний набір кроків, щоб
перемістити цей елемент на початок масиву. Однак, завдяки сортуванню Шеллом,
цей елемент може переходити більше ніж на один крок за раз і досягати
потрібного місця призначення за меншу кількість обмінів.

Shellsort працює, починаючи з достатньо великого (але не більшого за розмір
масиву) \(h_1\), щоб дозволити обмінюватися допустимими елементами, які
знаходяться на великій відстані один від одного. Після завершення сортування з
певним значенням \(h_1\) масив можна вважати відсортованим за \(h_1\).
Наступним кроком потрібно зменшити \(h_1\) на певну послідовність і знову
виконати ще одне повне \(h_2\)-сортування. Після того, як \(h_n\) дорівнює 1 і
\(h_n\)-сортування завершено, масив буде повністю відсортовано. Зверніть увагу,
що останнє значення \(h_n\) дорівнює 1, тому остання ітерація сортування завжди
є сортуванням вставкою, за винятком того, що на цей час масив вже добре
сформовано і його легше сортувати.

Сортування оболонкою використовує послідовність \(h_1,h_2,\dots,h_n\) яка називається
послідовністю інкрементів. Сортування оболонкою робить
декілька проходів по вхідному списку і сортує декілька однакових за розміром
наборів, використовуючи сортування вставками. Сортування оболонкою покращує
ефективність сортування вставкою, швидко переміщуючи елементи до місця
призначення.

\paragraph{Аналіз}
Сортування Шелла ефективне для списків середнього розміру. Для більших
списків цей алгоритм не є найкращим вибором. Це найшвидший з усіх алгоритмів
сортування \(O(n^2)\).

Цей алгоритм працює значно повільніше, ніж сортування злиттям, купою і швидке
сортування, але є відносно прости що робить його гарним вибором для
сортування масивів, що містять менше 5000 елементів, якщо швидкість не є
важливою. Це також хороший вибір для повторюваного сортування невеликих
списків.

Найкращий випадок для сортування Шелла - це коли масив вже відсортовано у
правильному порядку. Кількість порівнянь є меншою. Час виконання сортування
Шелла залежить від вибору послідовності інкрементів.

\section{Тестування}
\subsection{Про програму}
Програма для тестування алгоритмів написана на швидкій і компактній скриптовій мові
програмуванні \code{Lua}.
\paragraph{Структура}
\begin{description}
	\item[\code{algorithms.lua}] Функції алгоритмів Shell sort, Insertion sort.
	\item[\code{io.lua}] Функція для друкування масивів.
	\item[\code{options.lua}] Опис термінальних опцій та їхніх властивостей.
	\item[\code{random.lua}] Функція для генерування масивів фіксованої довжини з елементами в заданому проміжку.
	\item[\code{sort.lua}] Головний файл програми де всі вищезгадані методи виконуються.
\end{description}
\paragraph{Опції}
Програма має широкий набір опцій.
\begin{listing}[H]
	\centering
	\begin{minted}{text}
$  Lab1 lua sort.lua --help
Usage: lua sort.lua [-h] [-n INT] [-i INT] [-j INT] -a ALG [--version] [-v] [-q]

Generate random arrays and sort them.

Options:
   -h, --help            Show this help message and exit.
        -n INT,          Array size (default: 30)
   --count INT
       -i INT,           Minimum array element value (default: 1)
   --from INT
     -j INT,             Maximum array element value (default: 100)
   --to INT
            -a ALG,      Sorting algorithm name
   --algorithm ALG
   --version             Print version and exit
   -v, --verbose         Verbose mode. Print the sorting time in miliseconds
   -q, --quiet           Quiet mode. Do not print array contents to stdout

The arrays are generated randomly and can be sorted with
Shell and insertion sorting algorithms.
	\end{minted}
	\caption[Опція \code{---help}]{Вкорочена довідка по програмі (опція \code{---help})}
	\label{lst:help}
\end{listing}
\subsection{Запуск і перевірка алгоритмів}
Посортуємо кілька масивів.
\begin{listing}[H]
	\centering
	\begin{minted}{text}
$ Lab1 lua sort.lua --algorithm insertion '-i -1000' --to 1000 --verbose --count 20
1      -243
2      -687
3      -392
4      452
5      -424
6      707
7      -486
8      911
9      165
10     363
11     793
12     516
13     -917
14     426
15     -378
16     -787
17     -336
18     840
19     -852
20     -854

1      -917
2      -854
3      -852
4      -787
5      -687
6      -486
7      -424
8      -392
9      -378
10     -336
11     -243
12     165
13     363
14     426
15     452
16     516
17     707
18     793
19     840
20     911
sort.lua took 0.0200ms to sort array of size 20 with insertion sort
	\end{minted}
	\caption[Приклад сортування вставками]{Сортування масиву на 20 елементів алгоритмом вставки, кожен з яких лежить в проміжку \(n\in[1000;1000]\) при умові що \(n \in\mathbb{Z}\), з виводом вмісту масивів в стандартний потік}
	\label{lst:tag}
\end{listing}

\begin{listing}[H]
	\centering
	\begin{minted}{text}
$ Lab1 lua sort.lua --algorithm shell '-i -1000' --to 1000 --verbose --count 20
1      -855
2      724
3      766
4      455
5      363
6      -417
7      -827
8      -755
9      -119
10     -709
11     546
12     -869
13     -329
14     120
15     -186
16     -267
17     -306
18     73
19     -906
20     -444

1      -906
2      -869
3      -855
4      -827
5      -755
6      -709
7      -444
8      -417
9      -329
10     -306
11     -267
12     -186
13     -119
14     73
15     120
16     363
17     455
18     546
19     724
20     766
sort.lua took 0.0110ms to sort array of size 20 with shell sort
	\end{minted}
	\caption[Приклад сортування Шеллом]{Сортування масиву на 20 елементів алгоритмом Шелла, кожен з яких лежить в проміжку \(n\in[-1000;1000]\) при умові що \(n \in\mathbb{Z}\), з виводом вмісту масивів в стандартний потік}
	\label{lst:tag}
\end{listing}
\subsection{Порівняльний аналіз}
Порівняємо алгоритм Шелла та сортування вставками на \(\{10^n:n=\overline{1,7}\}\) кількості елементів.
Виклики \code{sort.lua} мають вигляд
\begin{listing}[H]
	\centering
	\begin{minted}{text}
lua sort.lua -a A '-i -1000' -j 1000 -vqn N
	\end{minted}
	\caption{Опції порівняльного аналізу}
	\label{lst:opts}
\end{listing}
Де \code{A} це алгоритм, а \code{N} це кількість елементів в масиві.

\begin{table}[H]
	\centering
	\caption{Порівняльний аналіз}
	\label{tab:analis}
	\begin{tabular}{cccccccc}
		\toprule
		Алгоритм &\(10^1\) &\(10^2\)&\(10^3\)&\(10^4\)&\(10^5\)&\(10^6\)&\(10^7\)\\
		\midrule
		Insertion & 0.011ms & 0.32ms & 22.23ms & 1260.4ms & 118567ms & > 30000ms & \dots\\
		Shell & 0.006ms & 0.057ms & 0.888ms & 10.686ms & 77.804ms & 667.772ms & 7245.482ms\\
		\bottomrule
	\end{tabular}
\end{table}
З таблиці \ref{tab:analis} можна зробити висновок що алгоритм Шелла більше підходить для сортування великих масивів.

\section{Висновки}
\begin{itemize}
	\item Ознайомився:
		\begin{itemize}
			\item З поняттям сортування масивів
			\item Сортуванням вставкою
			\item  Сортуванням Шелла
		\end{itemize}
	\item Вивчив:
		\begin{itemize}
			\item Основні алгоритми сортування
			\item Принципами аналізу обчислювальної складності алгоритмів
		\end{itemize}
	\item Реалізував:
		\begin{itemize}
			\item Програму для взаємодії з алгоритмами сортування
			\item Алгоритм сортування вставкою
			\item Алгоритм сортування Шелла
		\end{itemize}
\end{itemize}