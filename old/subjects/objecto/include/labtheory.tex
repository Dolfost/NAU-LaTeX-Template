\addcontentsline{lol}{section}{Теоретичні відомості}


\subsection[Умовний оператор \code{if else}]{Умовне розгалуження \mintinline{c}|if else|}
Якщо умова істинна, то відбувається перехід до тіла оператора \mintinline{c}|if|. В іншому випадку виконання програми переходить в оператор\footnote[1]{або блок} після \mintinline{c}|else|. Оператор \mintinline{c}|if| виконує тільки один оператор в залежності від істинності умови: або оператор після \mintinline{c}|if|, або оператор після \mintinline{c}|else|.
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		if(condition) {
			operator1;
			operator2;
			operator3;
		} else {
			operator1;
			operator2;
			operator3;
		}
	\end{minted}
	\caption[Синтаксис \code{if else}]{Синтаксис операторa умовного переходу \mintinline{c}|if else|}
	\label{lst:ifelseoperator}
\end{listing}

\subsection[Цикл \code{while}]{Оператор циклy \mintinline{c}|while|}
Оператор циклy while виконується до того моменту, поки задані умови (вираз) залишаються істинними. На початку циклу обробляється умова і якщо вона виконується, то тоді вже виконується саме тіло циклу. Однак, на відміну від оператора \mintinline{c}|if|, після завершення тіла циклу, виконання повертається назад до \mintinline{c}|while| і перевірка умов повторюється. Якщо умова істинна - цикл повторюється. Якщо умова оператора \mintinline{c}|while| не виконуються, то тоді тіло циклу пропускається і виконання програми переходить до першого оператора за циклом.
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		while(condition) {
			operator1;
			operator2;
			operator3;
		}
	\end{minted}
	\caption[Синтаксис \code{while}]{Синтаксис операторa циклу \mintinline{c}|while|}
	\label{lst:whileloop}
\end{listing}

\subsection[Цикл \code{for}]{Оператор циклу \mintinline{c}|for|}
Оператор циклу \mintinline{c}|for| зручно використовувати коли відома необхідна кількість дій. Тобто, в самому циклі спочатку перевіряється перша умова і якщо вона виконується - то тільки тоді перевіряється друга. В супротивному випадку виконання циклу зупиняється і здійснюється перехід до оператора, що знаходиться за тілом циклу. Потім виконується саме тіло циклу та після його виконання виконується \mintinline{c}|repeat|. Цикл буде продовжуватись до поки умова \mintinline{c}|condition| буде істинною.
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		for(one_time_action, condition, repeat) {
			operator1;
			operator2;
			operator3;
		}
	\end{minted}
	\caption[Синтаксис \code{for}]{Синтаксис операторa циклу \mintinline{c}|for|}
	\label{lst:forloop}
\end{listing}

\subsection[Функція \code{printf()}]{Функція \mintinline{c}|printf()|}
Функція \mintinline{c}|printf()| використовується для виводу даних на дисплей. Вона отримує один або більше аргументів: перший аргумент – це дані які потрібно візуалізувати. Якщо потрібно вивести значення якоїсь змінної, то потрібно: 
\begin{enumerate}
	\item зазначити вираз що починається зі знаку \mintinline{c}|%|
	\item вказати тип даних та формат для виведення
\end{enumerate}
Самі змінні вказуються після зазначення типу. Також, якщо в кінці функції \mintinline{c}|printf()| зазначити символ \mintinline{text}|\n|, то в кінці виводу каретка перейде на новий рядок.
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		int printf(const char* format, ... );
	\end{minted}
	\caption[Прототип \code{printf()}]{Прототип фкнкції \mintinline{c}|printf()|}
	\label{lst:f:printf}
\end{listing}
\paragraph{Параметри}
\begin{itemize}
	\item \mintinline{c}|format| - вказівник на багатобайтовий рядок з закінченням \mintinline{text}|\0|, що визначає спосіб інтерпретації даних
	\item \mintinline{c}|...| - аргументи, що визначають дані для друку. Якщо будь-який аргумент після просування аргументу за замовчуванням не є типом, очікуваним відповідним специфікатором перетворення, або якщо аргументів менше, ніж вимагається форматом, то поведінка не визначена. Якщо аргументів більше, ніж вимагається форматом, зайві аргументи обчислюються та ігноруються.
\end{itemize}

\subsection[Функція \code{malloc()}]{Фунція \mintinline{c}|malloc()|}
Функція \mintinline{c}|malloc()| виділяє пам'ять яка не використовуються. Якщо виділення пройшло успішно, то повертає вказівник, який можна привести до бажаного типу і використовувати виділену пам'ять через цей вказівник.
\paragraph{Поведінка функції}
Якщо розмір \mintinline{c}|size| дорівнює нулю, поведінка \mintinline{c}|malloc()| визначається реалізацією. Наприклад, може бути повернутий нульовий вказівник \mintinline{c}|NULL|. Може бути повернутий ненульовий вказівник, але з таким вказівником працювати не варто, його треба передати в \mintinline{c}|free()|, щоб уникнути витоку пам'яті.
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		void *malloc(size_t size);
	\end{minted}
	\caption[Прототип \code{malloc()}]{Прототип фкнкції \mintinline{c}|malloc()|}
	\label{lst:f:malloc}
\end{listing}
\paragraph{Параметри}
\begin{itemize}
	\item \mintinline{c}|size| - кількість байт для виділення
\end{itemize}

\subsection[Функція \code{calloc()}]{Функція \mintinline{c}|calloc()|}
\mintinline{c}|calloc()| виділяє пам'ять для масиву об'єктів розміром \mintinline{c}|num| та ініціалізує всі байти у виділеному сховищі нулем.
Якщо виділення пройшло успішно, повертає вказівник на молодший (перший) байт у виділеному блоці пам'яті, який приведений належним чином для будь-якого типу.
\paragraph{Поведінка функції}
Якщо \mintinline{c}|size| дорівнює нулю, то поведінка визначається реалізацією (може бути повернутий нульовий вказівник \mintinline{c}|NULL|, або деякий ненульовий вказівник, який не може бути використаний для доступу до пам'яті)
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		void *calloc(size_t num, size_t size);
	\end{minted}
	\caption[Прототип \code{calloc()}]{Прототип фкнкції \mintinline{c}|calloc()|}
	\label{lst:f:calloc}
\end{listing}
\paragraph{Параметри}
\begin{itemize}
	\item \mintinline{c}|num| - кількість об'єктів
	\item \mintinline{c}|size| - розмір кожного об'єкту
\end{itemize}

\subsection[Функція \code{realloc()}]{Функція \mintinline{c}|realloc()|}
Фкнція \mintinline{c}|realloc()| перерозподіляє задану область пам'яті. Вона повинна бути попередньо виділена \mintinline{c}|malloc()|, \mintinline{c}|calloc()| або \mintinline{c}|realloc()| і ще не звільнена викликом \mintinline{c}|free()|. В іншому випадку результати будуть невизначеними.
Перерозподіл здійснюється наступним чином:
\begin{enumerate}
	\item розширення або звуження існуючої області, на яку вказує \mintinline{c}|ptr|, якщо це можливо. Вміст області залишається незмінним до меншого з нових та старих розмірів. Якщо область розширюється, то вміст нової частини масиву не визначається.
	\item виділення нового блоку пам'яті розміром \mintinline{c}|new_size| байт, копіювання області пам'яті розміром, що дорівнює меншому з нового та старого розмірів, та звільнення старого блоку.
	Якщо пам'яті недостатньо, то старий блок пам'яті не звільняється і повертається нульовий вказівник \mintinline{c}|NULL|.
	Якщо \mintinline{c}|ptr| рівний \mintinline{c}|NULL|, то поведінка така сама як і при виклику \mintinline{c}|malloc(new_size)|.
\end{enumerate}
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		void *realloc( void *ptr, size_t new_size );
	\end{minted}
	\caption[Прототип \code{realloc()}]{Прототип фкнкції \mintinline{c}|realloc()|}
	\label{lst:f:realloc}
\end{listing}
\paragraph{Параметри}
\begin{itemize}
	\item \mintinline{c}|ptr| - вказівник на ділянку пам'яті, що перерозподіляється
	\item \mintinline{c}|new_size| - новий розмір масиву в байтах
\end{itemize}

\subsection[Функція \code{free()}]{Функція \mintinline{c}|free()|}
Функція \mintinline{c}|free()| звільняє місце, раніше виділене фунціями \mintinline{c}|malloc()|, \mintinline{c}|calloc()|, або \mintinline{c}|realloc()|.
Якщо \mintinline{c}|ptr| є нульовим покажчиком \mintinline{c}|NULL|, то функція нічого не робить.
\paragraph{Поведінка функції}
Поведінка не визначена, якщо значення \mintinline{c}|ptr| не дорівнює значенню, повернутому раніше функціями \mintinline{c}|malloc()|, \mintinline{c}|calloc()|, \mintinline{c}|realloc()|.
Також, поведінка не визначена, якщо область пам'яті, на яку посилається \mintinline{c}|ptr|, вже була звільнена, тобто функція \mintinline{c}|free()| або \mintinline{c}|realloc()| вже викликалась з аргументом \mintinline{c}|ptr| і жодні виклики \mintinline{c}|malloc()|, \mintinline{c}|calloc()|, \mintinline{c}|realloc()| не призвели до того, що після цього вказівник став рівним \mintinline{c}|ptr|.
Поведінка не визначена, якщо після роботи \mintinline{c}|free()| до пам'яті здійснюється доступ через вказівник \mintinline{c}|ptr| (якщо тільки інша функція виділення не призвела до того, що значення вказівника стало рівним \mintinline{c}|ptr|).
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		void free(void *ptr);
	\end{minted}
	\caption[Прототип \code{free()}]{Прототип фкнкції \mintinline{c}|free()|}
	\label{lst:f:free}
\end{listing}
\paragraph{Параметри}
\begin{itemize}
	\item \mintinline{c}|ptr| - вказівник на пам'ять для звільнення
\end{itemize}

\subsection[Функція \code{strlen()}]{Функція \mintinline{c}|strlen()|}
Фунція \mintinline{c}|strlen()| повертає довжину заданого байтового рядка з нульовим закінченням, тобто кількість символів у символьному масиві, на перший елемент якого вказує \mintinline{c}|str|, до першого нульового символу не включно.
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		size_t strlen(const char *str);
	\end{minted}
	\caption[Прототип \code{strlen()}]{Прототип фкнкції \mintinline{c}|strlen()|}
	\label{lst:f:strlen}
\end{listing}
\paragraph{Параметри}
\begin{itemize}
	\item \mintinline{c}|str| - вказівник на рядок з нульовим символом \mintinline{text}|\0| в кінці, що підлягає перевірці
\end{itemize}

\subsection[Фкнція \code{strcat()}]{Функція \mintinline{c}|strcat()|}
Функція \mintinline{c}|srtcat()| копію рядка з нульовим закінченням, на який вказує \mintinline{c}|src|, в кінець байтового рядка з нульовим закінченням, на який вказує dest. Символ \mintinline{c}|src[0]| замінює нульовий термінатор в кінці \mintinline{c}|dest|. Результуючий байтовий закінчкється на \mintinline{text}|\0|.
\paragraph{Поведінка функції}
Поведінка не визначена, якщо масив \mintinline{c}|dest| недостатньо великий для вмісту \mintinline{c}|src|, та немає місця для завершального нульового символу \mintinline{text}|\n|. Поведінка не визначена, якщо рядки перекриваються. Також, поведінка не визначена, якщо \mintinline{c}|dest| або \mintinline{c}|src| не є вказівником на рядок, що завершується на \mintinline{text}|\0|.
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		char *strcat(char *dest, const char *src);
	\end{minted}
	\caption[Прототип \code{strcat()}]{Прототип фкнкції \mintinline{c}|strcat()|}
	\label{lst:f:strcat}
\end{listing}
\paragraph{Параметри}
\begin{itemize}
	\item \mintinline{c}|dest| - вказівник на рядок з закінченням \mintinline{text}|\0|, до якого потрібно дописати рядок
	\item \mintinline{c}|src| - вказівник на байтовий рядок з закінченням \mintinline{text}|\0| для копіювання з нього
\end{itemize}

\subsection[Функція \code{strcmp()}]{Функція \mintinline{c}|strcmp()|}
Функція \mintinline{c}|strcmp()| порівнює два байтових рядки з нульовим закінченням лексикографічно.
Знаком результату є знак різниці між значеннями першої пари символів (обидва інтерпретуються як \mintinline{c}|unsigned char|), які відрізняються у порівнюваних рядках.
\paragraph{Поведінка функції}
Поведінка не визначена, якщо \mintinline{c}|lhs| або \mintinline{c}|rhs| не є вказівниками на рядки з нульовим закінченням \mintinline{text}|\0|.
\begin{listing}[H]
	\begin{minted}[numbers=none]{C}
		int strcmp(const char *lhs, const char *rhs);
	\end{minted}
	\caption[Прототип \code{strcmp()}]{Прототип фкнкції \mintinline{c}|strcmp()|}
	\label{lst:f:strcmp}
\end{listing}
\paragraph{Параметри}
\begin{itemize}
	\item \mintinline{c}|lhs|, \mintinline{c}|rhs| - вказівники на рядки з закінченням \mintinline{text}|\0| для порівняння
\end{itemize}

\subsection[Функція \code{memcpy()}]{Функція \mintinline{c}|memcpy()|}
\paragraph{Поведінка функції}
Поведінка не визначена, якщо доступ відбувається за межами кінця масиву \mintinline{c}|dest|. Якщо об'єкти перекриваються, то поведінка також не визначена. Поведінка не визначена, якщо або \mintinline{c}|dest|, або \mintinline{c}|src| є недопустимим або нульовим вказвіником \mintinline{c}|NULL|.
\begin{listing}[H]
	\begin{minted}[numbers=none]{c}
		void* memcpy(void *dest, const void *src, size_t count);
	\end{minted}
	\caption[Прототип \code{memcpy()}]{Прототип функції \mintinline{c}|memcpy()|}
	\label{lst:f:memcpy}
\end{listing}
\paragraph{Параметри}
\begin{itemize}
	\item \mintinline{c}|dest| - вказівник на місце, куди треба зберегти данні
	\item \mintinline{c}|src| - вказівник на місце, звідки брати дані для копіювання
	\item \mintinline{c}|count| - кількість байтів, які потрібно скопіювати
\end{itemize}
Фунція \mintinline{c}|memcpy()| копіює \mintinline{c}|count| символів з об'єкту на який  вказує \mintinline{c}|src| у \mintinline{c}|dest|. Обидва массиви інтерпретуються як массиви \mintinline{c}|unsigned char|.

\subsection[Функція \code{memset()}]{Функція \mintinline{c}|memset()|}
Функція \mintinline{c}|memset()| копіює значення \mintinline{c}|(unsigned char)ch| в кожен з перших \mintinline{c}|count| символів об'єкту, на який вказує \mintinline{c}|dest|.
\paragraph{Поведінка функції}
Поведінка не визначена, якщо доступ відбувається за межами кінця масиву \mintinline{c}|dest|. Також, поведінка не визначена, якщо \mintinline{c}|dest| є нульовим вказівником \mintinline{c}|NULL|.
\begin{listing}[H]
	\begin{minted}[numbers=none]{c}
		void *memset(void *dest, int ch, size_t count);
	\end{minted}
	\caption[Прототип \code{memset()}]{Прототип функції \mintinline{c}|memset()|}
	\label{lst:f:memset}
\end{listing}
\paragraph{Параметри}
\begin{itemize}
	\item \mintinline{c}|dest| - вказівник на об'єкт для заповнення
	\item \mintinline{c}|ch| - байт для заповнення
	\item \mintinline{c}|count| - кількість байтів, які потрібно заповнити
\end{itemize}

\addtocontents{lol}{\bigskip}